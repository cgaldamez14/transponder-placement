package simulator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import models.Link;
import models.Path;
import models.PathNode;
import models.PhysicalLink;
import models.PhysicalNode;
import models.Topology;
import models.VirtualLink;
import models.VirtualNode;
import models.VirtualRequest;
import utilities.DijkstraShortestPath;
import utilities.NetworkTopology;
import utilities.TopologyUtil;

public class Simulator {

	private int numberOfRequests = 100;    		// Default value for number of virtual request generated by simulator
	private int maxNodes = 2;					// Default value for max number of virtual nodes per virtual request
	
	private Topology topology;					// Topology generated by adjacency matrix

	private List<VirtualRequest> requests;		// List of virtual requests

	
	/**
	 * Constructor reads adjacency matrix for specified topology type
	 * @param type - Type of topology being used
	 * @throws IOException
	 */
	public Simulator(NetworkTopology type, int computationalAvailability, int bandwidthAvailability) throws IOException{
		this.topology = TopologyUtil.readAdjacencyMatrix(type, computationalAvailability, bandwidthAvailability);
	}
	
	// --------------------------------------- ACCESSORS -------------------------------------- //
	
	/**
	 * Gets the number of virtual requests the simulator is set to generate
	 * @return number of virtual request the simulator will generate
	 */
	public int getNumberOfRequests(){
		return numberOfRequests;
	}
	
	/**
	 * Gets the max number of nodes allowed for each virtual requests generated by the simulator
	 * @return max number of virtual nodes allowed for each virtual request
	 */
	public int getMaxNodes(){
		return maxNodes;
	}
	
	/**
	 * Gets the topology object generated by simulator
	 * @return topology object
	 */
	public Topology getTopology(){
		return topology;
	}
	
	// ---------------------------------------- MUTATORS ---------------------------------------- // 
	
	/**
	 * Sets the number of virtual requests the simulator must create
	 * @param numberOfRequests
	 */
	public void setNumberOfRequest(int numberOfRequests){
		this.numberOfRequests = numberOfRequests;
	}
	
	/**
	 * Sets the max number of virtual nodes a virtual request is allowed to have
	 * @param maxNodes
	 */
	public void setMaxNodes(int maxNodes){
		this.maxNodes = maxNodes;
	}
	
	// ---------------------------------------- OTHER METHODS ----------------------------------- //
	
	/**
	 * Generates number of requests. Default value is 100 requests unless other wise specified.
	 */
	public void generateRequests(){
		if(requests == null) this.requests = new ArrayList<>();

		for (int requestNumber = 0; requestNumber < numberOfRequests; requestNumber++){
			VirtualRequest request = new VirtualRequest(maxNodes, topology.getType());
			requests.add(request);
		}
	}
	
	
	private void updateTransponderBandwidth(Path path, int traffic){
		PathNode current = path.getStart();
		PathNode next = current.next();
		while(next != null){
//			if(current.getNodeID() == path.getStart().getNodeID()){
//				topology.getNodes().get(current.getNodeID()).incrementTBC(traffic);
//			}
//			else if(!current.hasNext()){
//				topology.getNodes().get(current.getNodeID()).incrementRBC(traffic);
//			}
//			else{
//				topology.getNodes().get(current.getNodeID()).incrementTBC(traffic);
//				topology.getNodes().get(current.getNodeID()).incrementRBC(traffic);
//			}
			topology.getLink(current.getNodeID(), next.getNodeID()).incrementTBC(current.getNodeID(), next.getNodeID(), traffic);
			current = next;
			next = next.next();
		}
	}
	
	public int getTranspondersODU(int transponderCapacity, int maxBandwidth, String distribution, boolean backupPath){
		
		for(VirtualRequest vr: requests){
			List<VirtualNode> virtualNodes = vr.getVirtualNodes();
			int start = virtualNodes.get(0).getMapID();
			int finish = virtualNodes.get(virtualNodes.size() - 1).getMapID();
			
			int traffic = -1;
			while(traffic <= 0 || traffic > maxBandwidth){
			traffic = (distribution.equals("uniform"))?Link.generateRandomBandwidthUniform(maxBandwidth):
								  (distribution.equals("gaussian"))?Link.generateRandomBandwidthGaussian(maxBandwidth):
												  					Link.generateRandomBandwidth(maxBandwidth);
			}
			
			DijkstraShortestPath dsp = new DijkstraShortestPath(topology, start, finish);
			updateTransponderBandwidth(dsp.getShortestPath(), traffic);
			
			if(backupPath) updateTransponderBandwidth(dsp.getDisjointShortestPath(), traffic);			
		}
		
		int totalTranspondersODU = 0;

		for(PhysicalLink l: topology.getLinks()){
			totalTranspondersODU += l.getTransponders(transponderCapacity);
		}
//		for(int i = 0; i < topology.getType().getNumberOfPhysicalNodes(); i++){
//			int transmittersNeeded = ((topology.getNodes().get(i).getTransmissionBandwidth() / transponderCapacity) + ((topology.getNodes().get(i).getTransmissionBandwidth() % transponderCapacity != 0)? 1:0));
//			int receiversNeeded = ((topology.getNodes().get(i).getReceivingBandwidth() / transponderCapacity) + ((topology.getNodes().get(i).getReceivingBandwidth() % transponderCapacity != 0)? 1:0));
//			totalTranspondersODU += (transmittersNeeded + receiversNeeded);
//		}
		
		return totalTranspondersODU;
	}
	
	public int getTransponderOTN(int transponderCapacity,int maxBandwidth, String distribution, boolean backupPath){
		
		int totalTranspondersOTN = 0; 
		
		for(int i = 0; i < numberOfRequests; i++){
			int traffic = -1;
			while(traffic <= 0 || traffic > maxBandwidth){
			traffic = (distribution.equals("uniform"))?Link.generateRandomBandwidthUniform(maxBandwidth):
								  (distribution.equals("gaussian"))?Link.generateRandomBandwidthGaussian(maxBandwidth):
												  					Link.generateRandomBandwidth(maxBandwidth);
			}
			
			totalTranspondersOTN += ((traffic / transponderCapacity) + ((traffic % transponderCapacity != 0)? 1:0)) * 2;
			if(backupPath) totalTranspondersOTN += ((traffic / transponderCapacity) + ((traffic % transponderCapacity != 0)? 1:0)) * 2;
		}
		
		return totalTranspondersOTN;
	}
	
	
	/**
	 * Removes all mappings for all virtual requests and returns all resources to physical links 
	 * and physical nodes
	 */
	public void resetAllResources(){
		
		topology.setRequestsMapped(0);
		
		for(VirtualRequest vr: requests){
			if(vr.isBlocked())
				vr.unblock();
			for(int i = 1; i < vr.getVirtualNodes().size() - 1; i++)
				vr.getVirtualNodes().get(i).setMap(-1);
			for(VirtualLink vl: vr.getVirtualLinks())
				vl.setLinkMapping(null);
		}
		
		for(Map.Entry<Integer, PhysicalNode> entry: topology.getNodes().entrySet())
			entry.getValue().setComputationAvailability(topology.getComputationalAvailability());
		
		for(PhysicalLink pl: topology.getLinks())
			pl.setBandwidthAvailability(topology.getBandwidthAvailability());
	}
	
}
